package path

import (
	"math/rand"
	"sync"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

// TransitEdge is a direct transportation between two locations.
type TransitEdge struct {
	VoyageNumber string    `json:"voyage"`
	Origin       string    `json:"origin"`
	Destination  string    `json:"destination"`
	Departure    time.Time `json:"departure"`
	Arrival      time.Time `json:"arrival"`
}

// TransitPath is a series of transit edges.
type TransitPath struct {
	Edges []TransitEdge `json:"edges"`
}

// FindShortestPath computes the shortest paths between two locations.
func FindShortestPath(origin, destination string) []TransitPath {

	var candidates []TransitPath

	for p := range generateCandidates(origin, destination, 6+rand.Intn(3)) {
		candidates = append(candidates, p)
	}

	return candidates
}

// generateCandidates generates new candidates and pushes them into a channel.
// Finding each candidate is potentially time-consuming, so we compute them in
// parallel.
func generateCandidates(origin, destination string, n int) chan TransitPath {
	ch := make(chan TransitPath)

	var wg sync.WaitGroup
	wg.Add(n)

	for i := 0; i < n; i++ {
		go func() {
			ch <- findCandidate(origin, destination, nextDate(time.Now()))
			wg.Done()
		}()
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	return ch
}

// findCandidate finds a random path between two locations starting from a
// given time.
func findCandidate(origin, destination string, start time.Time) TransitPath {
	v := allVertices(origin, destination)
	v = randChunk(v)

	var edges []TransitEdge

	edges, start = appendEdge(edges, origin, v[0], start)

	for j := 0; j < len(v)-1; j++ {
		edges, start = appendEdge(edges, v[j], v[j+1], start)
	}

	edges, _ = appendEdge(edges, v[len(v)-1], destination, start)

	return TransitPath{Edges: edges}
}

func appendEdge(edges []TransitEdge, curr, next string, date time.Time) ([]TransitEdge, time.Time) {
	var (
		from = nextDate(date)
		to   = nextDate(from)
	)

	edges = append(edges, TransitEdge{
		VoyageNumber: randVoyageNumber(),
		Origin:       curr,
		Destination:  next,
		Departure:    from,
		Arrival:      to,
	})

	return edges, nextDate(to)
}

func allVertices(origin, destination string) []string {
	locations := []string{"GYGEO", 
"TWSUO", 
"USGLF", 
"YUPUY", 
"VUPVI", 
"CLVAP", 
"JPKCZ", 
"PHTGO", 
"ILASH", 
"EGMEC", 
"USDAL", 
"SARIY", 
"USILM", 
"NZTRG", 
"AUBUR", 
"CNYNT", 
"GBHRW", 
"VUSAN", 
"BRPEC", 
"CNJIT", 
"USNEN", 
"IDMES", 
"GRSKG", 
"USGLS", 
"MYBKI", 
"USCHI", 
"CRCAL", 
"AUNTL", 
"PLGDY", 
"KRKJ*", 
"JPSSB", 
"NGPHC", 
"CAPT1", 
"IDPLM", 
"BEANR", 
"PHPPS", 
"PGRAB", 
"PGLAE", 
"BDCGP", 
"CNYIK", 
"USLAT", 
"JPYKK", 
"USLAR", 
"CLLQN", 
"KRMI*", 
"ZADUR", 
"USSE4", 
"USLGS", 
"PTLIS", 
"PGWWK", 
"CNDCB", 
"SBHIR", 
"KRKJC", 
"SESTO", 
"CAVAE", 
"CAVAD", 
"KRINC", 
"CAVAA", 
"USLGV", 
"CAVAC", 
"CAVAB", 
"TRMER", 
"NAWVB", 
"DEHBU", 
"CLMJS", 
"VEEGU", 
"BRITQ", 
"BNSER", 
"CAHAL", 
"ECGYE", 
"MXESE", 
"THSAT", 
"PHMIP", 
"THLEM", 
"GBHHD", 
"KRWD*", 
"PHBTG", 
"BRNVT", 
"ESLPA", 
"CLPAG", 
"JPFNB", 
"USSFO", 
"MYSBW", 
"CAVCJ", 
"CAYCR", 
"CAVCR", 
"CAKCR", 
"CNSZX", 
"USOAC", 
"JPYOK", 
"MXACA", 
"HRRJK", 
"SAGIZ", 
"ZAZBA", 
"CASJE", 
"USPHL", 
"USLXN", 
"VNTOU", 
"TWKAO", 
"BGVAR", 
"PYASU", 
"OMSLL", 
"CRPCD", 
"GBAVO", 
"YEADE", 
"GTSNJ", 
"GBTYN", 
"JPNGS", 
"TWKH1", 
"CNXNG", 
"CNZZU", 
"KRSG*", 
"CNNBO", 
"MOMAC", 
"EGPSD", 
"JPKOJ", 
"OMMCT", 
"EGALY", 
"COCTG", 
"BRRSH", 
"IDPDG", 
"USHST", 
"KRKAN", 
"CRPAS", 
"MYLMN", 
"KPNS*", 
"CLQTN", 
"SAJUB", 
"TZZNZ", 
"USLDC", 
"JPNGO", 
"PESJA", 
"JPSDS", 
"EGUCS", 
"CNSHY", 
"CATOR", 
"KRYC*", 
"CLARI", 
"USHNL", 
"AEFJR", 
"CAEDM", 
"PCPNI", 
"DKAAR", 
"MYWES", 
"ESCEU", 
"MUPLU", 
"FIRAU", 
"AUDPO", 
"JPIYM", 
"JPKIJ", 
"AUTSV", 
"BRSSZ", 
"ESMLN", 
"JPTOS", 
"CLSVE", 
"MYLBU", 
"SEMMA", 
"JPTKY", 
"GNCKY", 
"PHMNN", 
"INVTZ", 
"COSMR", 
"PABLB", 
"ITVPI", 
"GBGTN", 
"RUVVO", 
"JPSHS", 
"NZTIU", 
"ITRAN", 
"CNHUA", 
"KRMOK", 
"DJJIB", 
"ITGOA", 
"TWKEL", 
"ASPPG", 
"USSAV", 
"DODOM", 
"ESAGP", 
"TRIST", 
"BEGNE", 
"MYLWY", 
"CNNKG", 
"KRSP*", 
"NZBLU", 
"PHBUG", 
"IQBGW", 
"PAPTY", 
"INCCU", 
"USSEC", 
"USLA1", 
"KRKPO", 
"ITTRI", 
"USPAB", 
"JPUNO", 
"JPSKT", 
"JPHIC", 
"PECHM", 
"CNTSN", 
"DKAAL", 
"KRMAS", 
"HTPAP", 
"PCTKK", 
"PHSNG", 
"ANAUA", 
"AESHJ", 
"MYTWU", 
"GBIPS", 
"MXVER", 
"FRMRS", 
"INIXE", 
"CMDLA", 
"TWTXJ", 
"ISREK", 
"PECLF", 
"PHLUG", 
"TTPOS", 
"JPAIO", 
"MXMZT", 
"JPSGM", 
"KPJN*", 
"IRKHO", 
"USIPD", 
"SEGOT", 
"USMBS", 
"KRPTK", 
"JPMII", 
"JNTKO", 
"DKEBJ", 
"USSE5", 
"DEHUS", 
"SNDKR", 
"TRAYT", 
"GPPTP", 
"KHSHV", 
"GBLIV", 
"USSTI", 
"IRBSR", 
"PGROR", 
"JPONA", 
"KPHC*", 
"TWKEG", 
"CYLCA", 
"FRLEH", 
"NZNSN", 
"CNYTN", 
"GTPTQ", 
"WSAPW", 
"MMRGN", 
"CNDLC", 
"MACAS", 
"USNEW", 
"GBHUL", 
"COBUN", 
"KRKUV", 
"KRPET", 
"GBMNC", 
"USSE6", 
"TZDAR", 
"CLTHO", 
"INMDA", 
"CNWEI", 
"CNXMN", 
"BEZEE", 
"INJHT", 
"ESBIO", 
"KRDH*", 
"GHTEM", 
"NLAMS", 
"BRREC", 
"JPHSM", 
"JPHKT", 
"JPTRG", 
"USCSH", 
"AUALH", 
"AUBNE", 
"MXGYM", 
"KITRW", 
"USGPT", 
"BRITJ", 
"ESAMD", 
"IDJKT", 
"BSNAS", 
"INBOM", 
"INCOK", 
"BRSPB", 
"USMOB", 
"ROCND", 
"ZAPLZ", 
"USKSP", 
"MYSDK", 
"ITSVN", 
"GHTKD", 
"MXSAC", 
"KRALL", 
"USLGI", 
"PKKHI", 
"BRRIO", 
"AEKHL", 
"PEPIL", 
"ITTRS", 
"CNLYG", 
"MGTMM", 
"CNGNS", 
"INMUN", 
"JPHMD", 
"IDSUB", 
"JPIMI", 
"GRAST", 
"JPTAK", 
"OMSOH", 
"BSFPO", 
"JPOIP", 
"CLSAI", 
"VEMAR", 
"GALBV", 
"USCL9", 
"ITSPE", 
"USCL4", 
"CNZIN", 
"USCL7", 
"USLMW", 
"USCL1", 
"DZORN", 
"USCL3", 
"ILHFA", 
"USSCK", 
"BRQFS", 
"BDCHL", 
"PCYAP", 
"ITZZZ", 
"JPHRH", 
"NZNPE", 
"USMKE", 
"USCAR", 
"ITCAG", 
"JPMYJ", 
"LKCMB", 
"USIPI", 
"CNLKU", 
"JPHKP", 
"INMAA", 
"MXLCS", 
"NZWLG", 
"AUBME", 
"SDPZU", 
"JPAXT", 
"USCL2", 
"JPKOK", 
"AUDRW", 
"JPMKK", 
"ETASA", 
"DZAAE", 
"CHIWA", 
"SAYNB", 
"GUGUM", 
"HNPCR", 
"JPSDJ", 
"CNQZJ", 
"ZRMAT", 
"GBNCL", 
"PKBQM", 
"MXZLO", 
"USSTC", 
"CLANF", 
"VNSGN", 
"PFPPT", 
"JPSMZ", 
"TWTPE", 
"CNTAO", 
"INMAH", 
"AULST", 
"THLCH", 
"CNFUG", 
"USKDO", 
"ANCUR", 
"ZACPT", 
"ZAELS", 
"JPABU", 
"DEBRV", 
"TGLFW", 
"JPKUH", 
"SLFNA", 
"GBFXT", 
"MZMPM", 
"USSP6", 
"CNCZG", 
"USWCC", 
"VNHPH", 
"TNTUN", 
"SADMN", 
"CZWIL", 
"MYMYY", 
"EGADA", 
"CUHAV", 
"CNJIN", 
"RUNVS", 
"USSP5", 
"EGDAM", 
"RUVFP", 
"ITSAL", 
"JPHIJ", 
"AEJE4", 
"LYMRA", 
"KPJH*", 
"USDUT", 
"PGMAG", 
"USANC", 
"JPTMK", 
"JPTKS", 
"AOLOB", 
"KRSH*", 
"MYKCH", 
"NICIO", 
"VEPBL", 
"USCDE", 
"GIGIB", 
"BRPOA", 
"USBPT", 
"JPYWH", 
"TWTCG", 
"SGJUR", 
"JPMIJ", 
"MYLDU", 
"ITVCE", 
"CAMTR", 
"CNSKU", 
"USBBL", 
"PHPRO", 
"YUDBV", 
"JPMIS", 
"KROP*", 
"RUVYP", 
"KRCHA", 
"IRBKM", 
"CNQHA", 
"RUPWE", 
"JPNAO", 
"JPWAK", 
"KPJS*", 
"USTI1", 
"FRCER", 
"BZBZE", 
"CNDFL", 
"CNZJG", 
"PHSFE", 
"FJLTK", 
"GBSOU", 
"VUVLI", 
"PTSIE", 
"FRFOS", 
"PHMJJ", 
"VNVUT", 
"JPTKM", 
"JPSEN", 
"AUCNS", 
"JPFSK", 
"JPMAI", 
"MXPAN", 
"BNBTN", 
"USLBI", 
"CNWFG", 
"TRGEM", 
"JPOSA", 
"JPKRE", 
"CNFOC", 
"CNYAI", 
"TRDRC", 
"TWKHS", 
"MXTAM", 
"JPSKD", 
"CLIQQ", 
"PEILO", 
"MYKUD", 
"FRLAV", 
"CNTAG", 
"CNNNS", 
"KRDAS", 
"NGWAR", 
"KPNAM", 
"PHSBC", 
"NZDUD", 
"CALMN", 
"USECS", 
"JPIWK", 
"CNSWA", 
"USTCB", 
"USPAE", 
"GBGLW", 
"BRSSA", 
"YEHOD", 
"USMEM", 
"ECESM", 
"ITTAR", 
"KPJC*", 
"PEMRI", 
"GBGRG", 
"USLGT", 
"GRHER", 
"CNSHA", 
"BRMAO", 
"NGCBG", 
"PGGUR", 
"IDBPN", 
"BBBGI", 
"BAKBS", 
"USYYW", 
"USLGC", 
"RUKOR", 
"TWKA2", 
"SAJED", 
"JPSMN", 
"MYJOH", 
"USYYG", 
"GBLEI", 
"DZBJA", 
"CNHKG", 
"BRRIG", 
"SUDOS", 
"USYYI", 
"CNJNZ", 
"JPHBK", 
"EGSOK", 
"MXLZ2", 
"JPFKY", 
"JPTHS", 
"MYJAM", 
"LYTIP", 
"USWSS", 
"BRFOR", 
"GBLON", 
"KHKOS", 
"EGEDK", 
"KMYVA", 
"JPNAH", 
"USSEK", 
"VNDAD", 
"ITNPO", 
"USSEX", 
"KRJP*", 
"GRATH", 
"USJAX", 
"BRIGI", 
"MZBEW", 
"TRKPX", 
"SIKOP", 
"ESVLC", 
"GTPRQ", 
"USTCD", 
"AUBEL", 
"USLXS", 
"AEDXB", 
"MYTPP", 
"KRPU1", 
"LKTRR", 
"ESBCN", 
"KPCHO", 
"NOAES", 
"PFPP5", 
"USLGN", 
"TWHUN", 
"UAILK", 
"GBTIL", 
"ITGIT", 
"JPSAE", 
"NOOSL", 
"NGAPP", 
"DKCPH", 
"INNSA", 
"USLAM", 
"FJSUV", 
"USTPA", 
"ITCTA", 
"JPKNU", 
"NCNOU", 
"NZLYT", 
"USSEA", 
"PEPAI", 
"AEAUH", 
"USPEF", 
"JPCHB", 
"JPISI", 
"COBAQ", 
"KRMUK", 
"SRPBM", 
"USBAL", 
"AUADL", 
"CNYAN", 
"THBKK", 
"QADOH", 
"USSTL", 
"NZORR", 
"CNRZH", 
"GBTHP", 
"JPDEJ", 
"USEWR", 
"ROVIS", 
"JPHHE", 
"JPABR", 
"AUSYD", 
"GRPIR", 
"FRBOD", 
"JPKWS", 
"AOLAD", 
"KPHGM", 
"HNAMP", 
"PACTB", 
"CNSHD", 
"CAQUE", 
"DDRSK", 
"BRSUA", 
"HNSLO", 
"NRINU", 
"CYLMS", 
"KWKWI", 
"SVAQJ", 
"CIABJ", 
"JPUBJ", 
"ZAMZY", 
"NGLOS", 
"AEMQA", 
"JPMUR", 
"PGKVG", 
"ARBUE", 
"MXLZC", 
"JPYAT", 
"JPSBS", 
"BJCOO", 
"SOMGQ", 
"USHOU", 
"KRCM*", 
"CNSKO", 
"SOKMU", 
"PAONX", 
"KEMBA", 
"NZCHC", 
"RUNJK", 
"FITKU", 
"USORF", 
"KROS*", 
"GBHTP", 
"AUPHE", 
"KRPNC", 
"USWSC", 
"MYPKL", 
"KRKH*", 
"PHCEB", 
"KRUSN", 
"TWTTT", 
"JPUKB", 
"CNTGA", 
"PAMZX", 
"JPOTK", 
"USNYC", 
"IEDUB", 
"NGTIN", 
"JPKSM", 
"ESPMI", 
"TRIZM", 
"YUZAD", 
"JMKIN", 
"KRYOS", 
"MTMLA", 
"JPMOJ", 
"EGSUZ", 
"USMLB", 
"USLDN", 
"GBEDI", 
"NLRTM", 
"USELZ", 
"IDBLW", 
"MXZL2", 
"CAMTL", 
"USCHS", 
"TRISK", 
"VELAG", 
"ITPMO", 
"BDMON", 
"KPSW*", 
"AUFRE", 
"GMBJL", 
"USMIA", 
"MYPEN", 
"USMIW", 
"NZNPL", 
"IEORK", 
"NODRM", 
"CNFAN", 
"USDET", 
"MYPGU", 
"JPKNZ", 
"JPNKN", 
"CRPLD", 
"MHMAJ", 
"STTMS", 
"SAFUJ", 
"USMCB", 
"MYBTU", 
"AEKLF", 
"CYFMG", 
"FJSU5", 
"NZPOE", 
"PGPOM", 
"RULED", 
"TZTGT", 
"GBPME", 
"AUGEX", 
"JPISS", 
"USMWS", 
"ILETH", 
"USBOS", 
"BRVIX", 
"AUMEL", 
"IDUPG", 
"PGKIM", 
"JPIMB", 
"ITGTO", 
"BRPNG", 
"GBABD", 
"PLGDN", 
"ESALG", 
"PHCGY", 
"KRGAM", 
"IDPNK", 
"FIHEL", 
"KRPYT", 
"LRMLW", 
"IDDUM", 
"DEHAM", 
"UYMVD", 
"PCSPN", 
"PHGES", 
"MGMJN", 
"VCSVD", 
"USWCS", 
"SPACE", 
"IDSRG", 
"KRSUK", 
"CAVA1", 
"YUSPU", 
"AUHBA", 
"VEMTV", 
"KRSHO", 
"RUVST", 
"LBBEY", 
"NZAKL", 
"TOTBU", 
"SGSI3", 
"KRCHF", 
"JOAQJ", 
"INIXY", 
"USSPQ", 
"MRNKC", 
"CGPNR", 
"PHDVO"}
	for i, l := range locations {
		if l == origin {
			locations = append(locations[:i], locations[i+1:]...)
		}
	}
	for i, l := range locations {
		if l == destination {
			locations = append(locations[:i], locations[i+1:]...)
		}
	}
	return locations
}

func randVoyageNumber() string {
	switch rand.Intn(5) {
	case 0:
		return "0100S"
	case 1:
		return "0200T"
	case 2:
		return "0300A"
	case 3:
		return "0301S"
	}
	return "0400S"
}

func randChunk(locations []string) []string {

	shuffle(locations)

	t := len(locations)

	var c int
	if t > 4 {
		c = 1 + rand.Intn(5)
	} else {
		c = t
	}

	return locations[:c]
}

func shuffle(slc []string) {
	for i := 1; i < len(slc); i++ {
		r := rand.Intn(i + 1)
		if i != r {
			slc[r], slc[i] = slc[i], slc[r]
		}
	}
}

func nextDate(t time.Time) time.Time {
	n := time.Duration(rand.Intn(1000) - 500)
	return t.Add(24 * time.Hour).Add(n * time.Minute)
}
